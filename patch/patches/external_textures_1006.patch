diff --git content/browser/compositor/browser_compositor_output_surface.cc content/browser/compositor/browser_compositor_output_surface.cc
index 924e82dadab4..ceaffb54026a 100644
--- content/browser/compositor/browser_compositor_output_surface.cc
+++ content/browser/compositor/browser_compositor_output_surface.cc
@@ -62,6 +62,10 @@ void BrowserCompositorOutputSurface::SetReflector(ReflectorImpl* reflector) {
   OnReflectorChanged();
 }

+void* BrowserCompositorOutputSurface::GetSharedTexture() const {
+  return nullptr;
+}
+
 void BrowserCompositorOutputSurface::OnReflectorChanged() {
 }

diff --git content/browser/compositor/browser_compositor_output_surface.h content/browser/compositor/browser_compositor_output_surface.h
index 941d70bd2a7e..ef14a7dd7d4f 100644
--- content/browser/compositor/browser_compositor_output_surface.h
+++ content/browser/compositor/browser_compositor_output_surface.h
@@ -41,6 +41,8 @@ class CONTENT_EXPORT BrowserCompositorOutputSurface

   void SetReflector(ReflectorImpl* reflector);

+  virtual void* GetSharedTexture() const;
+
   // Called when |reflector_| was updated.
   virtual void OnReflectorChanged();

diff --git content/browser/compositor/gpu_process_transport_factory.cc content/browser/compositor/gpu_process_transport_factory.cc
index 511d805187b1..e4a897541bc7 100644
--- content/browser/compositor/gpu_process_transport_factory.cc
+++ content/browser/compositor/gpu_process_transport_factory.cc
@@ -209,6 +209,18 @@ GpuProcessTransportFactory::~GpuProcessTransportFactory() {
   task_graph_runner_->Shutdown();
 }

+void* GpuProcessTransportFactory::GetSharedTexture(ui::Compositor* compositor) {
+  PerCompositorDataMap::iterator it = per_compositor_data_.find(compositor);
+  if (it == per_compositor_data_.end())
+    return nullptr;
+  PerCompositorData* data = it->second.get();
+  DCHECK(data);
+
+  if (data->display_output_surface)
+    return data->display_output_surface->GetSharedTexture();
+  return nullptr;
+}
+
 std::unique_ptr<viz::SoftwareOutputDevice>
 GpuProcessTransportFactory::CreateSoftwareOutputDevice(
     gfx::AcceleratedWidget widget,
@@ -506,7 +518,8 @@ void GpuProcessTransportFactory::EstablishedGpuChannel(
         display_output_surface =
             std::make_unique<OffscreenBrowserCompositorOutputSurface>(
                 context_provider, std::move(vsync_callback),
-                std::unique_ptr<viz::CompositorOverlayCandidateValidator>());
+                std::unique_ptr<viz::CompositorOverlayCandidateValidator>(),
+                compositor->shared_texture_enabled());
       } else if (capabilities.surfaceless) {
 #if defined(OS_MACOSX)
         const auto& gpu_feature_info = context_provider->GetGpuFeatureInfo();
@@ -986,7 +999,8 @@ GpuProcessTransportFactory::CreatePerCompositorData(
   gfx::AcceleratedWidget widget = compositor->widget();

   auto data = std::make_unique<PerCompositorData>();
-  if (widget == gfx::kNullAcceleratedWidget) {
+  if (widget == gfx::kNullAcceleratedWidget ||
+      compositor->shared_texture_enabled()) {
     data->surface_handle = gpu::kNullSurfaceHandle;
   } else {
 #if defined(GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW)
diff --git content/browser/compositor/gpu_process_transport_factory.h content/browser/compositor/gpu_process_transport_factory.h
index 6704fa4bb4c2..4f9397da64aa 100644
--- content/browser/compositor/gpu_process_transport_factory.h
+++ content/browser/compositor/gpu_process_transport_factory.h
@@ -104,6 +104,7 @@ class GpuProcessTransportFactory : public ui::ContextFactory,
   void IssueExternalBeginFrame(ui::Compositor* compositor,
                                const viz::BeginFrameArgs& args) override;
   void SetOutputIsSecure(ui::Compositor* compositor, bool secure) override;
+  void* GetSharedTexture(ui::Compositor* compositor) override;

   // ImageTransportFactory implementation.
   void DisableGpuCompositing() override;
diff --git content/browser/compositor/offscreen_browser_compositor_output_surface.cc content/browser/compositor/offscreen_browser_compositor_output_surface.cc
index 3b3dc6943a68..941ba4f3cf2b 100644
--- content/browser/compositor/offscreen_browser_compositor_output_surface.cc
+++ content/browser/compositor/offscreen_browser_compositor_output_surface.cc
@@ -33,10 +33,12 @@ OffscreenBrowserCompositorOutputSurface::
         scoped_refptr<ui::ContextProviderCommandBuffer> context,
         const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
         std::unique_ptr<viz::CompositorOverlayCandidateValidator>
-            overlay_candidate_validator)
+            overlay_candidate_validator,
+        bool shared_texture_enabled)
     : BrowserCompositorOutputSurface(std::move(context),
                                      update_vsync_parameters_callback,
                                      std::move(overlay_candidate_validator)),
+      shared_texture_enabled_(shared_texture_enabled),
       weak_ptr_factory_(this) {
   capabilities_.uses_default_gl_framebuffer = false;
 }
@@ -46,6 +48,10 @@ OffscreenBrowserCompositorOutputSurface::
   DiscardBackbuffer();
 }

+void* OffscreenBrowserCompositorOutputSurface::GetSharedTexture() const {
+  return (void*)shared_handle_;
+}
+
 void OffscreenBrowserCompositorOutputSurface::BindToClient(
     viz::OutputSurfaceClient* client) {
   DCHECK(client);
@@ -54,42 +60,72 @@ void OffscreenBrowserCompositorOutputSurface::BindToClient(
 }

 void OffscreenBrowserCompositorOutputSurface::EnsureBackbuffer() {
-  bool update_source_texture = !reflector_texture_ || reflector_changed_;
-  reflector_changed_ = false;
-  if (!reflector_texture_) {
-    reflector_texture_.reset(new ReflectorTexture(context_provider()));
-
-    GLES2Interface* gl = context_provider_->ContextGL();
-
-    const int max_texture_size =
-        context_provider_->ContextCapabilities().max_texture_size;
-    int texture_width = std::min(max_texture_size, reshape_size_.width());
-    int texture_height = std::min(max_texture_size, reshape_size_.height());
-
-    gl->BindTexture(GL_TEXTURE_2D, reflector_texture_->texture_id());
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    gl->TexImage2D(GL_TEXTURE_2D, 0, GLInternalFormat(kFboTextureFormat),
-                   texture_width, texture_height, 0,
-                   GLDataFormat(kFboTextureFormat),
-                   GLDataType(kFboTextureFormat), nullptr);
+  GLES2Interface* gl = context_provider_->ContextGL();
+
+  const int max_texture_size =
+      context_provider_->ContextCapabilities().max_texture_size;
+  int texture_width = std::min(max_texture_size, reshape_size_.width());
+  int texture_height = std::min(max_texture_size, reshape_size_.height());
+
+  GLuint color_attachment = 0;
+
+  if (shared_texture_enabled_) {
+    if (!shared_handle_ && (texture_width > 0) && (texture_height > 0)) {
+      gl->GenTextures(1, &shared_texture_);
+      gl->BindTexture(GL_TEXTURE_2D, shared_texture_);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      shared_handle_ = gl->CreateSharedTexture(shared_texture_, texture_width,
+                                               texture_height);
+
+      if (shared_handle_) {
+        color_attachment = shared_texture_;
+      } else {
+        gl->DeleteTextures(1, &shared_texture_);
+        shared_texture_ = 0;
+      }
+    }
+  } else {
+    // The shared texture code above in theory could work with the reflector
+    // texture However, there were issues making associating it a shared surface
+    // and then attaching it to the FBO (incomplete?)
+    bool update_source_texture = !reflector_texture_ || reflector_changed_;
+    reflector_changed_ = false;
+    if (!reflector_texture_) {
+      reflector_texture_.reset(new ReflectorTexture(context_provider()));
+
+      gl->BindTexture(GL_TEXTURE_2D, reflector_texture_->texture_id());
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      gl->TexImage2D(GL_TEXTURE_2D, 0, GLInternalFormat(kFboTextureFormat),
+                     texture_width, texture_height, 0,
+                     GLDataFormat(kFboTextureFormat),
+                     GLDataType(kFboTextureFormat), nullptr);
+
+      color_attachment = reflector_texture_->texture_id();
+
+      // The reflector may be created later or detached and re-attached,
+      // so don't assume it always exists. For example, ChromeOS always
+      // creates a reflector asynchronosly when creating this for software
+      // mirroring.  See |DisplayManager::CreateMirrorWindowAsyncIfAny|.
+      if (reflector_ && update_source_texture)
+        reflector_->OnSourceTextureMailboxUpdated(
+            reflector_texture_->mailbox());
+    }
+  }
+
+  if (color_attachment) {
     if (!fbo_)
       gl->GenFramebuffers(1, &fbo_);

     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
     gl->FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                             GL_TEXTURE_2D, reflector_texture_->texture_id(),
-                             0);
+                             GL_TEXTURE_2D, color_attachment, 0);
   }
-
-  // The reflector may be created later or detached and re-attached,
-  // so don't assume it always exists. For example, ChromeOS always
-  // creates a reflector asynchronosly when creating this for software
-  // mirroring.  See |DisplayManager::CreateMirrorWindowAsyncIfAny|.
-  if (reflector_ && update_source_texture)
-    reflector_->OnSourceTextureMailboxUpdated(reflector_texture_->mailbox());
 }

 void OffscreenBrowserCompositorOutputSurface::DiscardBackbuffer() {
@@ -101,6 +137,16 @@ void OffscreenBrowserCompositorOutputSurface::DiscardBackbuffer() {
       reflector_->OnSourceTextureMailboxUpdated(nullptr);
   }

+  if (shared_handle_) {
+    gl->DeleteSharedTexture(shared_handle_);
+    shared_handle_ = 0ull;
+  }
+
+  if (shared_texture_) {
+    gl->DeleteTextures(1, &shared_texture_);
+    shared_texture_ = 0;
+  }
+
   if (fbo_) {
     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
     gl->DeleteFramebuffers(1, &fbo_);
@@ -125,15 +171,20 @@ void OffscreenBrowserCompositorOutputSurface::Reshape(
 }

 void OffscreenBrowserCompositorOutputSurface::BindFramebuffer() {
-  bool need_to_bind = !!reflector_texture_.get();
+  GLES2Interface* gl = context_provider_->ContextGL();

+  bool need_to_bind = !!reflector_texture_.get();
   EnsureBackbuffer();
-  DCHECK(reflector_texture_.get());
   DCHECK(fbo_);

-  if (need_to_bind) {
-    GLES2Interface* gl = context_provider_->ContextGL();
+  if (shared_handle_) {
     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
+    gl->LockSharedTexture(shared_handle_);
+  } else {
+    DCHECK(reflector_texture_.get());
+    if (need_to_bind) {
+      gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
+    }
   }
 }

@@ -154,6 +205,12 @@ void OffscreenBrowserCompositorOutputSurface::SwapBuffers(
   // The original implementation had a flickering issue (crbug.com/515332).
   gpu::gles2::GLES2Interface* gl = context_provider_->ContextGL();

+  // if using a shared texture, we need to Flush
+  if (shared_handle_) {
+    gl->UnlockSharedTexture(shared_handle_);
+    gl->Flush();
+  }
+
   gpu::SyncToken sync_token;
   gl->GenUnverifiedSyncTokenCHROMIUM(sync_token.GetData());
   context_provider_->ContextSupport()->SignalSyncToken(
@@ -195,8 +252,11 @@ void OffscreenBrowserCompositorOutputSurface::OnSwapBuffersComplete(
     bool need_presentation_feedback) {
   latency_tracker_.OnGpuSwapBuffersCompleted(latency_info);
   client_->DidReceiveSwapBuffersAck();
-  if (need_presentation_feedback)
-    client_->DidReceivePresentationFeedback(gfx::PresentationFeedback());
+  if (need_presentation_feedback) {
+	  gfx::PresentationFeedback feedback;
+	  feedback.timestamp = base::TimeTicks::Now();
+	  client_->DidReceivePresentationFeedback(feedback);
+  }
 }

 #if BUILDFLAG(ENABLE_VULKAN)
diff --git content/browser/compositor/offscreen_browser_compositor_output_surface.h content/browser/compositor/offscreen_browser_compositor_output_surface.h
index f123692aebb5..a726730a9bcc 100644
--- content/browser/compositor/offscreen_browser_compositor_output_surface.h
+++ content/browser/compositor/offscreen_browser_compositor_output_surface.h
@@ -32,7 +32,8 @@ class OffscreenBrowserCompositorOutputSurface
       scoped_refptr<ui::ContextProviderCommandBuffer> context,
       const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
       std::unique_ptr<viz::CompositorOverlayCandidateValidator>
-          overlay_candidate_validator);
+          overlay_candidate_validator,
+      bool shared_texture_enabled);

   ~OffscreenBrowserCompositorOutputSurface() override;

@@ -54,6 +55,8 @@ class OffscreenBrowserCompositorOutputSurface
   gfx::BufferFormat GetOverlayBufferFormat() const override;
   uint32_t GetFramebufferCopyTextureFormat() override;

+  void* GetSharedTexture() const override;
+
   // BrowserCompositorOutputSurface implementation.
   void OnReflectorChanged() override;

@@ -63,6 +66,8 @@ class OffscreenBrowserCompositorOutputSurface

   unsigned UpdateGpuFence() override;

+  void NotifyRenderHost(const std::vector<ui::LatencyInfo>& latency_info);
+
   void OnSwapBuffersComplete(const std::vector<ui::LatencyInfo>& latency_info,
                              bool need_presentation_feedback);

@@ -71,6 +76,11 @@ class OffscreenBrowserCompositorOutputSurface
   uint32_t fbo_ = 0;
   bool reflector_changed_ = false;
   std::unique_ptr<ReflectorTexture> reflector_texture_;
+
+  bool shared_texture_enabled_ = false;
+  uint64_t shared_handle_ = 0ull;
+  uint32_t shared_texture_ = 0;
+
   ui::LatencyTracker latency_tracker_;
   base::WeakPtrFactory<OffscreenBrowserCompositorOutputSurface>
       weak_ptr_factory_;
diff --git content/browser/compositor/viz_process_transport_factory.cc content/browser/compositor/viz_process_transport_factory.cc
index af692aeb080a..03baac924f9a 100644
--- content/browser/compositor/viz_process_transport_factory.cc
+++ content/browser/compositor/viz_process_transport_factory.cc
@@ -276,6 +276,10 @@ bool VizProcessTransportFactory::IsGpuCompositingDisabled() {
   return is_gpu_compositing_disabled();
 }

+void* VizProcessTransportFactory::GetSharedTexture(ui::Compositor* compositor) {
+  return nullptr;
+}
+
 ui::ContextFactory* VizProcessTransportFactory::GetContextFactory() {
   return this;
 }
diff --git content/browser/compositor/viz_process_transport_factory.h content/browser/compositor/viz_process_transport_factory.h
index 731a309d53ab..c7a717de8914 100644
--- content/browser/compositor/viz_process_transport_factory.h
+++ content/browser/compositor/viz_process_transport_factory.h
@@ -80,6 +80,8 @@ class VizProcessTransportFactory : public ui::ContextFactory,
   ui::ContextFactoryPrivate* GetContextFactoryPrivate() override;
   viz::GLHelper* GetGLHelper() override;

+  void* GetSharedTexture(ui::Compositor* compositor) override;
+
   // viz::ContextLostObserver implementation.
   void OnContextLost() override;

diff --git gpu/GLES2/gl2chromium_autogen.h gpu/GLES2/gl2chromium_autogen.h
index 2a9a622cf9b1..0b70d596ac6d 100644
--- gpu/GLES2/gl2chromium_autogen.h
+++ gpu/GLES2/gl2chromium_autogen.h
@@ -403,5 +403,9 @@
 #define glDestroyGpuFenceCHROMIUM GLES2_GET_FUN(DestroyGpuFenceCHROMIUM)
 #define glInvalidateReadbackBufferShadowDataCHROMIUM \
   GLES2_GET_FUN(InvalidateReadbackBufferShadowDataCHROMIUM)
+#define glCreateSharedTexture GLES2_GET_FUN(CreateSharedTexture)
+#define glLockSharedTexture GLES2_GET_FUN(LockSharedTexture)
+#define glUnlockSharedTexture GLES2_GET_FUN(UnlockSharedTexture)
+#define glDeleteSharedTexture GLES2_GET_FUN(DeleteSharedTexture)

 #endif  // GPU_GLES2_GL2CHROMIUM_AUTOGEN_H_
diff --git gpu/command_buffer/build_gles2_cmd_buffer.py gpu/command_buffer/build_gles2_cmd_buffer.py
index 10b3292a2a47..1857ca02ac7d 100755
--- gpu/command_buffer/build_gles2_cmd_buffer.py
+++ gpu/command_buffer/build_gles2_cmd_buffer.py
@@ -4035,6 +4035,35 @@ _FUNCTION_INFO = {
     'extension': 'CHROMIUM_gpu_fence',
     'extension_flag': 'chromium_gpu_fence',
   },
+  'CreateSharedTexture': {
+    'type': 'Custom',
+    'data_transfer_methods': ['shm'],
+    'cmd_args': 'GLint texture_id, GLint width, '
+                'GLint height, GLuint64* result',
+    'result': ['GLuint64'],
+    'unit_test': False,
+    'impl_func': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'LockSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'UnlockSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'DeleteSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
   'UnpremultiplyAndDitherCopyCHROMIUM': {
     'decoder_func': 'DoUnpremultiplyAndDitherCopyCHROMIUM',
     'cmd_args': 'GLuint source_id, GLuint dest_id, GLint x, GLint y, '
diff --git gpu/command_buffer/client/gles2_c_lib_autogen.h gpu/command_buffer/client/gles2_c_lib_autogen.h
index 0ba79c43b82b..a2dcf68997ce 100644
--- gpu/command_buffer/client/gles2_c_lib_autogen.h
+++ gpu/command_buffer/client/gles2_c_lib_autogen.h
@@ -1796,6 +1796,20 @@ void GL_APIENTRY
 GLES2InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) {
   gles2::GetGLContext()->InvalidateReadbackBufferShadowDataCHROMIUM(buffer_id);
 }
+GLuint64 GL_APIENTRY GLES2CreateSharedTexture(GLuint texture_id,
+                                              GLsizei width,
+                                              GLsizei height) {
+  return gles2::GetGLContext()->CreateSharedTexture(texture_id, width, height);
+}
+void GL_APIENTRY GLES2LockSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->LockSharedTexture(shared_handle);
+}
+void GL_APIENTRY GLES2UnlockSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->UnlockSharedTexture(shared_handle);
+}
+void GL_APIENTRY GLES2DeleteSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->DeleteSharedTexture(shared_handle);
+}

 namespace gles2 {

@@ -3149,6 +3163,22 @@ extern const NameToFunc g_gles2_function_table[] = {
         reinterpret_cast<GLES2FunctionPointer>(
             glInvalidateReadbackBufferShadowDataCHROMIUM),
     },
+    {
+        "glCreateSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glCreateSharedTexture),
+    },
+    {
+        "glLockSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glLockSharedTexture),
+    },
+    {
+        "glUnlockSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glUnlockSharedTexture),
+    },
+    {
+        "glDeleteSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glDeleteSharedTexture),
+    },
     {
         NULL, NULL,
     },
diff --git gpu/command_buffer/client/gles2_cmd_helper.h gpu/command_buffer/client/gles2_cmd_helper.h
index 4c31d1e8d42d..594478eeb597 100644
--- gpu/command_buffer/client/gles2_cmd_helper.h
+++ gpu/command_buffer/client/gles2_cmd_helper.h
@@ -21,10 +21,10 @@ class GPU_GLES2_EXPORT GLES2CmdHelper : public CommandBufferHelper {
   explicit GLES2CmdHelper(CommandBuffer* command_buffer);
   ~GLES2CmdHelper() override;

-  // Include the auto-generated part of this class. We split this because it
-  // means we can easily edit the non-auto generated parts right here in this
-  // file instead of having to edit some template or the code generator.
-  #include "gpu/command_buffer/client/gles2_cmd_helper_autogen.h"
+// Include the auto-generated part of this class. We split this because it
+// means we can easily edit the non-auto generated parts right here in this
+// file instead of having to edit some template or the code generator.
+#include "gpu/command_buffer/client/gles2_cmd_helper_autogen.h"

   // Helpers that could not be auto-generated.

@@ -36,4 +36,3 @@ class GPU_GLES2_EXPORT GLES2CmdHelper : public CommandBufferHelper {
 }  // namespace gpu

 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_CMD_HELPER_H_
-
diff --git gpu/command_buffer/client/gles2_cmd_helper_autogen.h gpu/command_buffer/client/gles2_cmd_helper_autogen.h
index d755f730989f..7aeb8d002790 100644
--- gpu/command_buffer/client/gles2_cmd_helper_autogen.h
+++ gpu/command_buffer/client/gles2_cmd_helper_autogen.h
@@ -3328,4 +3328,40 @@ void SetReadbackBufferShadowAllocationINTERNAL(GLuint buffer_id,
   }
 }

+void CreateSharedTexture(GLint texture_id,
+                         GLint width,
+                         GLint height,
+                         uint32_t result_shm_id,
+                         uint32_t result_shm_offset) {
+  gles2::cmds::CreateSharedTexture* c =
+      GetCmdSpace<gles2::cmds::CreateSharedTexture>();
+  if (c) {
+    c->Init(texture_id, width, height, result_shm_id, result_shm_offset);
+  }
+}
+
+void LockSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::LockSharedTexture* c =
+      GetCmdSpace<gles2::cmds::LockSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
+void UnlockSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::UnlockSharedTexture* c =
+      GetCmdSpace<gles2::cmds::UnlockSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
+void DeleteSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::DeleteSharedTexture* c =
+      GetCmdSpace<gles2::cmds::DeleteSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_CMD_HELPER_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_implementation.cc gpu/command_buffer/client/gles2_implementation.cc
index 33cd9dce8be6..15cc27b68823 100644
--- gpu/command_buffer/client/gles2_implementation.cc
+++ gpu/command_buffer/client/gles2_implementation.cc
@@ -7151,6 +7151,22 @@ void GLES2Implementation::Viewport(GLint x,
   CheckGLError();
 }

+GLuint64 GLES2Implementation::CreateSharedTexture(GLuint texture_id,
+                                                  GLsizei width,
+                                                  GLsizei height) {
+  typedef cmds::CreateSharedTexture::Result Result;
+  Result* result = GetResultAs<Result*>();
+  if (!result) {
+    return 0;
+  }
+  *result = 0;
+  helper_->CreateSharedTexture(texture_id, width, height, GetResultShmId(),
+                               GetResultShmOffset());
+
+  WaitForCmd();
+  return *result;
+}
+
 void GLES2Implementation::IssueBeginQuery(GLenum target,
                                           GLuint id,
                                           uint32_t sync_data_shm_id,
diff --git gpu/command_buffer/client/gles2_implementation_autogen.h gpu/command_buffer/client/gles2_implementation_autogen.h
index 56e005c81394..bc8efcb1224c 100644
--- gpu/command_buffer/client/gles2_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_autogen.h
@@ -1260,4 +1260,14 @@ void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;

 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;

+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+
+void LockSharedTexture(GLuint64 shared_handle) override;
+
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+
+void DeleteSharedTexture(GLuint64 shared_handle) override;
+
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_IMPLEMENTATION_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_implementation_impl_autogen.h gpu/command_buffer/client/gles2_implementation_impl_autogen.h
index b90e63c69b95..4d505e828aad 100644
--- gpu/command_buffer/client/gles2_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_impl_autogen.h
@@ -3617,4 +3617,28 @@ void GLES2Implementation::DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) {
   CheckGLError();
 }

+void GLES2Implementation::LockSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glLockSharedTexture("
+                     << shared_handle << ")");
+  helper_->LockSharedTexture(shared_handle);
+  CheckGLError();
+}
+
+void GLES2Implementation::UnlockSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glUnlockSharedTexture("
+                     << shared_handle << ")");
+  helper_->UnlockSharedTexture(shared_handle);
+  CheckGLError();
+}
+
+void GLES2Implementation::DeleteSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glDeleteSharedTexture("
+                     << shared_handle << ")");
+  helper_->DeleteSharedTexture(shared_handle);
+  CheckGLError();
+}
+
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_IMPLEMENTATION_IMPL_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_interface_autogen.h gpu/command_buffer/client/gles2_interface_autogen.h
index 69f860d187a3..8b031746761f 100644
--- gpu/command_buffer/client/gles2_interface_autogen.h
+++ gpu/command_buffer/client/gles2_interface_autogen.h
@@ -937,4 +937,10 @@ virtual GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) = 0;
 virtual void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) = 0;
 virtual void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) = 0;
 virtual void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) = 0;
+virtual GLuint64 CreateSharedTexture(GLuint texture_id,
+                                     GLsizei width,
+                                     GLsizei height) = 0;
+virtual void LockSharedTexture(GLuint64 shared_handle) = 0;
+virtual void UnlockSharedTexture(GLuint64 shared_handle) = 0;
+virtual void DeleteSharedTexture(GLuint64 shared_handle) = 0;
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_INTERFACE_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_interface_stub_autogen.h gpu/command_buffer/client/gles2_interface_stub_autogen.h
index 7258000c8551..f552caa17640 100644
--- gpu/command_buffer/client/gles2_interface_stub_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_autogen.h
@@ -908,4 +908,10 @@ GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) override;
 void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;
+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+void LockSharedTexture(GLuint64 shared_handle) override;
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+void DeleteSharedTexture(GLuint64 shared_handle) override;
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_INTERFACE_STUB_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
index 055f62edb466..45235e9ba979 100644
--- gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
@@ -1223,4 +1223,12 @@ void GLES2InterfaceStub::WaitGpuFenceCHROMIUM(GLuint /* gpu_fence_id */) {}
 void GLES2InterfaceStub::DestroyGpuFenceCHROMIUM(GLuint /* gpu_fence_id */) {}
 void GLES2InterfaceStub::InvalidateReadbackBufferShadowDataCHROMIUM(
     GLuint /* buffer_id */) {}
+GLuint64 GLES2InterfaceStub::CreateSharedTexture(GLuint /* texture_id */,
+                                                 GLsizei /* width */,
+                                                 GLsizei /* height */) {
+  return 0;
+}
+void GLES2InterfaceStub::LockSharedTexture(GLuint64 /* shared_handle */) {}
+void GLES2InterfaceStub::UnlockSharedTexture(GLuint64 /* shared_handle */) {}
+void GLES2InterfaceStub::DeleteSharedTexture(GLuint64 /* shared_handle */) {}
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_INTERFACE_STUB_IMPL_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_trace_implementation_autogen.h gpu/command_buffer/client/gles2_trace_implementation_autogen.h
index 94ee13d3111e..a2c940ea07f2 100644
--- gpu/command_buffer/client/gles2_trace_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_autogen.h
@@ -908,4 +908,10 @@ GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) override;
 void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;
+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+void LockSharedTexture(GLuint64 shared_handle) override;
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+void DeleteSharedTexture(GLuint64 shared_handle) override;
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_TRACE_IMPLEMENTATION_AUTOGEN_H_
diff --git gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
index 0933cce010a9..962bac3811ac 100644
--- gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
@@ -2611,4 +2611,26 @@ void GLES2TraceImplementation::InvalidateReadbackBufferShadowDataCHROMIUM(
   gl_->InvalidateReadbackBufferShadowDataCHROMIUM(buffer_id);
 }

+GLuint64 GLES2TraceImplementation::CreateSharedTexture(GLuint texture_id,
+                                                       GLsizei width,
+                                                       GLsizei height) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::CreateSharedTexture");
+  return gl_->CreateSharedTexture(texture_id, width, height);
+}
+
+void GLES2TraceImplementation::LockSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::LockSharedTexture");
+  gl_->LockSharedTexture(shared_handle);
+}
+
+void GLES2TraceImplementation::UnlockSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::UnlockSharedTexture");
+  gl_->UnlockSharedTexture(shared_handle);
+}
+
+void GLES2TraceImplementation::DeleteSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::DeleteSharedTexture");
+  gl_->DeleteSharedTexture(shared_handle);
+}
+
 #endif  // GPU_COMMAND_BUFFER_CLIENT_GLES2_TRACE_IMPLEMENTATION_IMPL_AUTOGEN_H_
diff --git gpu/command_buffer/common/gles2_cmd_format_autogen.h gpu/command_buffer/common/gles2_cmd_format_autogen.h
index 155b3a4da265..631cd4881d7e 100644
--- gpu/command_buffer/common/gles2_cmd_format_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_autogen.h
@@ -16406,4 +16406,191 @@ static_assert(
     offsetof(SetReadbackBufferShadowAllocationINTERNAL, size) == 16,
     "offset of SetReadbackBufferShadowAllocationINTERNAL size should be 16");

+struct CreateSharedTexture {
+  typedef CreateSharedTexture ValueType;
+  static const CommandId kCmdId = kCreateSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  typedef GLuint64 Result;
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLint _texture_id,
+            GLint _width,
+            GLint _height,
+            uint32_t _result_shm_id,
+            uint32_t _result_shm_offset) {
+    SetHeader();
+    texture_id = _texture_id;
+    width = _width;
+    height = _height;
+    result_shm_id = _result_shm_id;
+    result_shm_offset = _result_shm_offset;
+  }
+
+  void* Set(void* cmd,
+            GLint _texture_id,
+            GLint _width,
+            GLint _height,
+            uint32_t _result_shm_id,
+            uint32_t _result_shm_offset) {
+    static_cast<ValueType*>(cmd)->Init(_texture_id, _width, _height,
+                                       _result_shm_id, _result_shm_offset);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  int32_t texture_id;
+  int32_t width;
+  int32_t height;
+  uint32_t result_shm_id;
+  uint32_t result_shm_offset;
+};
+
+static_assert(sizeof(CreateSharedTexture) == 24,
+              "size of CreateSharedTexture should be 24");
+static_assert(offsetof(CreateSharedTexture, header) == 0,
+              "offset of CreateSharedTexture header should be 0");
+static_assert(offsetof(CreateSharedTexture, texture_id) == 4,
+              "offset of CreateSharedTexture texture_id should be 4");
+static_assert(offsetof(CreateSharedTexture, width) == 8,
+              "offset of CreateSharedTexture width should be 8");
+static_assert(offsetof(CreateSharedTexture, height) == 12,
+              "offset of CreateSharedTexture height should be 12");
+static_assert(offsetof(CreateSharedTexture, result_shm_id) == 16,
+              "offset of CreateSharedTexture result_shm_id should be 16");
+static_assert(offsetof(CreateSharedTexture, result_shm_offset) == 20,
+              "offset of CreateSharedTexture result_shm_offset should be 20");
+
+struct LockSharedTexture {
+  typedef LockSharedTexture ValueType;
+  static const CommandId kCmdId = kLockSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(LockSharedTexture) == 12,
+              "size of LockSharedTexture should be 12");
+static_assert(offsetof(LockSharedTexture, header) == 0,
+              "offset of LockSharedTexture header should be 0");
+static_assert(offsetof(LockSharedTexture, shared_handle_0) == 4,
+              "offset of LockSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(LockSharedTexture, shared_handle_1) == 8,
+              "offset of LockSharedTexture shared_handle_1 should be 8");
+
+struct UnlockSharedTexture {
+  typedef UnlockSharedTexture ValueType;
+  static const CommandId kCmdId = kUnlockSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(UnlockSharedTexture) == 12,
+              "size of UnlockSharedTexture should be 12");
+static_assert(offsetof(UnlockSharedTexture, header) == 0,
+              "offset of UnlockSharedTexture header should be 0");
+static_assert(offsetof(UnlockSharedTexture, shared_handle_0) == 4,
+              "offset of UnlockSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(UnlockSharedTexture, shared_handle_1) == 8,
+              "offset of UnlockSharedTexture shared_handle_1 should be 8");
+
+struct DeleteSharedTexture {
+  typedef DeleteSharedTexture ValueType;
+  static const CommandId kCmdId = kDeleteSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(DeleteSharedTexture) == 12,
+              "size of DeleteSharedTexture should be 12");
+static_assert(offsetof(DeleteSharedTexture, header) == 0,
+              "offset of DeleteSharedTexture header should be 0");
+static_assert(offsetof(DeleteSharedTexture, shared_handle_0) == 4,
+              "offset of DeleteSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(DeleteSharedTexture, shared_handle_1) == 8,
+              "offset of DeleteSharedTexture shared_handle_1 should be 8");
+
 #endif  // GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_FORMAT_AUTOGEN_H_
diff --git gpu/command_buffer/common/gles2_cmd_format_test_autogen.h gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
index d66f4ab06dd8..b9bb18421b9e 100644
--- gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
@@ -5435,4 +5435,50 @@ TEST_F(GLES2FormatTest, SetReadbackBufferShadowAllocationINTERNAL) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }

+TEST_F(GLES2FormatTest, CreateSharedTexture) {
+  cmds::CreateSharedTexture& cmd = *GetBufferAs<cmds::CreateSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLint>(11), static_cast<GLint>(12),
+                           static_cast<GLint>(13), static_cast<uint32_t>(14),
+                           static_cast<uint32_t>(15));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::CreateSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLint>(11), cmd.texture_id);
+  EXPECT_EQ(static_cast<GLint>(12), cmd.width);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.height);
+  EXPECT_EQ(static_cast<uint32_t>(14), cmd.result_shm_id);
+  EXPECT_EQ(static_cast<uint32_t>(15), cmd.result_shm_offset);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, LockSharedTexture) {
+  cmds::LockSharedTexture& cmd = *GetBufferAs<cmds::LockSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::LockSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, UnlockSharedTexture) {
+  cmds::UnlockSharedTexture& cmd = *GetBufferAs<cmds::UnlockSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::UnlockSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, DeleteSharedTexture) {
+  cmds::DeleteSharedTexture& cmd = *GetBufferAs<cmds::DeleteSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::DeleteSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 #endif  // GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_FORMAT_TEST_AUTOGEN_H_
diff --git gpu/command_buffer/common/gles2_cmd_ids_autogen.h gpu/command_buffer/common/gles2_cmd_ids_autogen.h
index ea899109cd21..9ea4caac0f6e 100644
--- gpu/command_buffer/common/gles2_cmd_ids_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_ids_autogen.h
@@ -341,7 +341,11 @@
   OP(CreateGpuFenceINTERNAL)                               /* 582 */ \
   OP(WaitGpuFenceCHROMIUM)                                 /* 583 */ \
   OP(DestroyGpuFenceCHROMIUM)                              /* 584 */ \
-  OP(SetReadbackBufferShadowAllocationINTERNAL)            /* 585 */
+  OP(SetReadbackBufferShadowAllocationINTERNAL)            /* 585 */ \
+  OP(CreateSharedTexture)                                  /* 586 */ \
+  OP(LockSharedTexture)                                    /* 587 */ \
+  OP(UnlockSharedTexture)                                  /* 588 */ \
+  OP(DeleteSharedTexture)                                  /* 589 */

 enum CommandId {
   kOneBeforeStartPoint =
diff --git gpu/command_buffer/gles2_cmd_buffer_functions.txt gpu/command_buffer/gles2_cmd_buffer_functions.txt
index 3ae935646764..fff188622ed4 100644
--- gpu/command_buffer/gles2_cmd_buffer_functions.txt
+++ gpu/command_buffer/gles2_cmd_buffer_functions.txt
@@ -394,3 +394,9 @@ GL_APICALL void         GL_APIENTRY glDestroyGpuFenceCHROMIUM (GLuint gpu_fence_
 GL_APICALL void         GL_APIENTRY glInvalidateReadbackBufferShadowDataCHROMIUM (GLidBuffer buffer_id);
 // (used for CHROMIUM_nonblocking_readback implementation)
 GL_APICALL void         GL_APIENTRY glSetReadbackBufferShadowAllocationINTERNAL (GLidBuffer buffer_id, GLint shm_id, GLuint shm_offset, GLuint size);
+
+// shared handle extensions
+GL_APICALL GLuint64     GL_APIENTRY glCreateSharedTexture (GLuint texture_id, GLsizei width, GLsizei height);
+GL_APICALL void         GL_APIENTRY glLockSharedTexture (GLuint64 shared_handle);
+GL_APICALL void         GL_APIENTRY glUnlockSharedTexture (GLuint64 shared_handle);
+GL_APICALL void         GL_APIENTRY glDeleteSharedTexture (GLuint64 shared_handle);
\ No newline at end of file
diff --git gpu/command_buffer/service/BUILD.gn gpu/command_buffer/service/BUILD.gn
index a8a16dcc822c..3ea299b1d9c6 100644
--- gpu/command_buffer/service/BUILD.gn
+++ gpu/command_buffer/service/BUILD.gn
@@ -116,6 +116,8 @@ target(link_target_type, "gles2_sources") {
     "decoder_context.h",
     "error_state.cc",
     "error_state.h",
+    "external_texture_manager.cc",
+    "external_texture_manager.h",
     "feature_info.cc",
     "feature_info.h",
     "framebuffer_completeness_cache.cc",
diff --git gpu/command_buffer/service/external_texture_manager.cc gpu/command_buffer/service/external_texture_manager.cc
new file mode 100644
index 000000000000..d37691a5aa3c
--- /dev/null
+++ gpu/command_buffer/service/external_texture_manager.cc
@@ -0,0 +1,334 @@
+#include "external_texture_manager.h"
+
+#include "third_party/khronos/EGL/egl.h"
+#include "third_party/khronos/EGL/eglext.h"
+#include "ui/gl/gl_bindings.h"
+#include "ui/gl/gl_image.h"
+#include "ui/gl/gl_surface_egl.h"
+
+#include "gpu/command_buffer/service/service_utils.h"
+#include "ui/gl/gl_context_egl.h"
+#include "ui/gl/init/gl_factory.h"
+
+#if defined(OS_WIN)
+#include <d3d11_1.h>
+#include "ui/gl/gl_angle_util_win.h"
+#include "ui/gl/gl_image_dxgi.h"
+#endif
+
+#ifndef EGL_ANGLE_d3d_texture_client_buffer
+#define EGL_ANGLE_d3d_texture_client_buffer 1
+#define EGL_D3D_TEXTURE_ANGLE 0x33A3
+#endif /* EGL_ANGLE_d3d_texture_client_buffer */
+
+namespace gpu {
+namespace gles2 {
+
+#if defined(OS_WIN)
+class GLImageDXGISharedHandle : public gl::GLImageDXGIBase {
+ public:
+  GLImageDXGISharedHandle(const gfx::Size& size)
+      : GLImageDXGIBase(size),
+        handle_((HANDLE)0),
+        surface_(EGL_NO_SURFACE),
+        texture_id_(0) {}
+
+  void* share_handle() const { return handle_; }
+
+  bool Initialize() {
+    Microsoft::WRL::ComPtr<ID3D11Device> d3d11_device =
+        gl::QueryD3D11DeviceObjectFromANGLE();
+    if (!d3d11_device) {
+      return false;
+    }
+
+    Microsoft::WRL::ComPtr<ID3D11Device1> d3d11_device1;
+    HRESULT hr = d3d11_device.As(&d3d11_device1);
+    if (FAILED(hr)) {
+      return false;
+    }
+
+    D3D11_TEXTURE2D_DESC td = {0};
+    td.ArraySize = 1;
+    td.CPUAccessFlags = 0;
+    td.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
+    td.Width = GetSize().width();
+    td.Height = GetSize().height();
+    td.MipLevels = 1;
+    td.SampleDesc.Count = 1;
+    td.SampleDesc.Quality = 0;
+    td.Usage = D3D11_USAGE_DEFAULT;
+    td.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;
+    td.MiscFlags = 0;
+
+    hr = d3d11_device1->CreateTexture2D(&td, nullptr, texture_.GetAddressOf());
+    if (FAILED(hr)) {
+      return false;
+    }
+
+    // Create a staging texture that will not be a render-target, but will be
+    // shared.  We could make the render target directly shareable, but the
+    // staged copy is safer for synchronization and less problematic
+    td.BindFlags = D3D11_BIND_SHADER_RESOURCE;
+    td.MiscFlags = D3D11_RESOURCE_MISC_SHARED;
+    hr = d3d11_device1->CreateTexture2D(&td, nullptr,
+                                        staging_texture_.GetAddressOf());
+    if (FAILED(hr)) {
+      return false;
+    }
+
+    // If using a staging texture ... then we need the shared handle for that
+    Microsoft::WRL::ComPtr<IDXGIResource> dxgi_res;
+    if (staging_texture_.Get()) {
+      hr = staging_texture_.As(&dxgi_res);
+    } else {
+      hr = texture_.As(&dxgi_res);
+    }
+    if (SUCCEEDED(hr)) {
+      dxgi_res->GetSharedHandle(&handle_);
+    }
+
+    return true;
+  }
+
+  void Lock() {
+    // in the future - a keyed mutex could be utilized here
+  }
+
+  void Unlock() {
+    if (staging_texture_.Get() && texture_.Get()) {
+      Microsoft::WRL::ComPtr<ID3D11Device> d3d11_device;
+      staging_texture_->GetDevice(&d3d11_device);
+      if (d3d11_device.Get()) {
+        Microsoft::WRL::ComPtr<ID3D11DeviceContext> d3d11_ctx;
+        d3d11_device->GetImmediateContext(&d3d11_ctx);
+        if (d3d11_ctx.Get()) {
+          d3d11_ctx->CopyResource(staging_texture_.Get(), texture_.Get());
+        }
+      }
+    }
+  }
+
+  void SetSurface(EGLSurface surface, GLuint texture_id) {
+    surface_ = surface;
+    texture_id_ = texture_id;
+  }
+
+  EGLSurface surface() const { return surface_; }
+
+  GLuint texture_id() const { return texture_id_; }
+
+ protected:
+  ~GLImageDXGISharedHandle() override {}
+
+ private:
+  HANDLE handle_;
+  Microsoft::WRL::ComPtr<ID3D11Texture2D> staging_texture_;
+  EGLSurface surface_;
+  GLuint texture_id_;
+};
+
+#endif
+
+ExternalTextureManager::ExternalTextureManager() {}
+
+ExternalTextureManager::~ExternalTextureManager() {}
+
+void* ExternalTextureManager::CreateTexture(GLuint texture_id,
+                                            uint32_t width,
+                                            uint32_t height,
+                                            TextureManager* tex_man) {
+  void* share_handle = nullptr;
+
+#if defined(OS_WIN)
+  EGLDisplay egl_display = gl::GLSurfaceEGL::GetHardwareDisplay();
+  if (egl_display == EGL_NO_DISPLAY) {
+    return nullptr;
+  }
+
+  EGLContext curContext = eglGetCurrentContext();
+  if (curContext == EGL_NO_CONTEXT) {
+    return nullptr;
+  }
+
+  gfx::Size size(width, height);
+  scoped_refptr<gl::GLImage> image;
+  void* texture = nullptr;
+
+  GLImageDXGISharedHandle* dxgi_image = new GLImageDXGISharedHandle(size);
+  if (!dxgi_image->Initialize()) {
+    return nullptr;
+  }
+  image = dxgi_image;
+  share_handle = dxgi_image->share_handle();
+  texture = dxgi_image->texture().Get();
+
+  if (!image) {  // this check seems unnecessary
+    return nullptr;
+  }
+
+  EGLint numConfigs = 0;
+  EGLint configAttrs[] = {
+      EGL_RENDERABLE_TYPE,
+      EGL_OPENGL_ES3_BIT,  // must remain in this position for ES2 fallback
+      EGL_SURFACE_TYPE,
+      EGL_PBUFFER_BIT,
+      EGL_BUFFER_SIZE,
+      32,
+      EGL_RED_SIZE,
+      8,
+      EGL_GREEN_SIZE,
+      8,
+      EGL_BLUE_SIZE,
+      8,
+      EGL_ALPHA_SIZE,
+      8,
+      EGL_DEPTH_SIZE,
+      0,
+      EGL_STENCIL_SIZE,
+      0,
+      EGL_SAMPLE_BUFFERS,
+      0,
+      EGL_NONE};
+
+  EGLConfig config = nullptr;
+  if (eglChooseConfig(egl_display, configAttrs, &config, 1, &numConfigs) !=
+      EGL_TRUE) {
+    return nullptr;
+  }
+
+  EGLSurface surface = EGL_NO_SURFACE;
+  EGLint surfAttrs[] = {EGL_WIDTH,
+                        width,
+                        EGL_HEIGHT,
+                        height,
+                        EGL_TEXTURE_TARGET,
+                        EGL_TEXTURE_2D,
+                        EGL_TEXTURE_FORMAT,
+                        EGL_TEXTURE_RGBA,
+                        EGL_NONE};
+
+  surface = eglCreatePbufferFromClientBuffer(egl_display, EGL_D3D_TEXTURE_ANGLE,
+                                             texture, config, surfAttrs);
+  if (surface == EGL_NO_SURFACE) {
+    // fallback to ES2 - it could be that we're running on older hardware
+    // and ES3 isn't available
+
+    // EGL_RENDERABLE_TYPE is the bit at configAttrs[0]
+    configAttrs[1] = EGL_OPENGL_ES2_BIT;
+    config = nullptr;
+    if (eglChooseConfig(egl_display, configAttrs, &config, 1, &numConfigs) ==
+        EGL_TRUE) {
+      surface = eglCreatePbufferFromClientBuffer(
+          egl_display, EGL_D3D_TEXTURE_ANGLE, texture, config, surfAttrs);
+    }
+
+    // still no surface? we're done
+    if (surface == EGL_NO_SURFACE) {
+      return nullptr;
+    }
+  }
+
+  dxgi_image->SetSurface(surface, texture_id);
+
+  surfaceMap_[share_handle] = image;
+
+  EGLSurface drawSurface = eglGetCurrentSurface(EGL_DRAW);
+  EGLSurface readSurface = eglGetCurrentSurface(EGL_READ);
+
+  eglMakeCurrent(egl_display, surface, surface, curContext);
+
+  if (eglBindTexImage(egl_display, surface, EGL_BACK_BUFFER)) {
+    if (tex_man) {
+      TextureRef* texture_ref = tex_man->GetTexture(texture_id);
+      tex_man->SetLevelInfo(texture_ref, GL_TEXTURE_2D, 0, GL_BGRA_EXT, width,
+                            height, 1, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE,
+                            gfx::Rect(size));
+      tex_man->SetLevelImage(texture_ref, GL_TEXTURE_2D, 0, image.get(),
+                             Texture::BOUND);
+    }
+  }
+
+  eglMakeCurrent(egl_display, drawSurface, readSurface, curContext);
+
+#endif
+
+  return share_handle;
+}
+
+void ExternalTextureManager::LockTexture(void* handle) {
+#if defined(OS_WIN)
+  auto const img = surfaceMap_.find(handle);
+  if (img != surfaceMap_.end()) {
+    GLImageDXGISharedHandle* dxgi_image =
+        reinterpret_cast<GLImageDXGISharedHandle*>(img->second.get());
+    dxgi_image->Lock();
+  }
+#endif
+}
+
+void ExternalTextureManager::UnlockTexture(void* handle) {
+#if defined(OS_WIN)
+  auto const img = surfaceMap_.find(handle);
+  if (img != surfaceMap_.end()) {
+    GLImageDXGISharedHandle* dxgi_image =
+        reinterpret_cast<GLImageDXGISharedHandle*>(img->second.get());
+    dxgi_image->Unlock();
+  }
+#endif
+}
+
+void ExternalTextureManager::DeleteTexture(void* handle,
+                                           TextureManager* tex_man) {
+#if defined(OS_WIN)
+
+  EGLDisplay egl_display = gl::GLSurfaceEGL::GetHardwareDisplay();
+  if (egl_display == EGL_NO_DISPLAY) {
+    return;
+  }
+  auto const img = surfaceMap_.find(handle);
+  if (img == surfaceMap_.end()) {
+    return;
+  }
+
+  EGLSurface surface = EGL_NO_SURFACE;
+  GLuint texture_id = 0;
+
+  GLImageDXGISharedHandle* dxgi_image =
+      reinterpret_cast<GLImageDXGISharedHandle*>(img->second.get());
+  surface = dxgi_image->surface();
+  texture_id = dxgi_image->texture_id();
+
+  if (surface != EGL_NO_SURFACE) {
+    EGLContext curContext = eglGetCurrentContext();
+    if (curContext != EGL_NO_CONTEXT) {
+      EGLSurface drawSurface = eglGetCurrentSurface(EGL_DRAW);
+      EGLSurface readSurface = eglGetCurrentSurface(EGL_READ);
+
+      eglMakeCurrent(egl_display, surface, surface, curContext);
+
+      TextureRef* texture_ref = nullptr;
+      if (tex_man) {
+        texture_ref = tex_man->GetTexture(texture_id);
+      }
+
+      eglReleaseTexImage(egl_display, surface, EGL_BACK_BUFFER);
+
+      if (tex_man && texture_ref) {
+        tex_man->SetLevelInfo(texture_ref, GL_TEXTURE_2D, 0, GL_RGBA, 0, 0, 1,
+                              0, GL_RGBA, GL_UNSIGNED_BYTE, gfx::Rect());
+        tex_man->SetLevelImage(texture_ref, GL_TEXTURE_2D, 0, nullptr,
+                               Texture::UNBOUND);
+      }
+
+      eglMakeCurrent(egl_display, drawSurface, readSurface, curContext);
+
+      eglDestroySurface(egl_display, surface);
+    }
+  }
+  surfaceMap_.erase(img);
+
+#endif
+}
+}
+}  // namespace gpu
diff --git gpu/command_buffer/service/external_texture_manager.h gpu/command_buffer/service/external_texture_manager.h
new file mode 100644
index 000000000000..6b82be94a670
--- /dev/null
+++ gpu/command_buffer/service/external_texture_manager.h
@@ -0,0 +1,42 @@
+#ifndef EXTERNAL_TEXTURE_MANAGER_H_
+#define EXTERNAL_TEXTURE_MANAGER_H_
+#pragma once
+
+#include <map>
+
+#include "gpu/command_buffer/service/texture_manager.h"
+#include "gpu/gpu_export.h"
+#include "ui/gl/gl_image.h"
+#include "ui/gl/gl_surface_egl.h"
+
+namespace gl {
+class GLImage;
+}
+
+namespace gpu {
+namespace gles2 {
+
+class GPU_GLES2_EXPORT ExternalTextureManager {
+ public:
+  ExternalTextureManager();
+  ~ExternalTextureManager();
+
+  void* CreateTexture(GLuint texture_id,
+                      uint32_t width,
+                      uint32_t height,
+                      TextureManager* tex_man);
+
+  void LockTexture(void* handle);
+  void UnlockTexture(void* handle);
+
+  void DeleteTexture(void* handle, TextureManager* tex_man);
+
+ private:
+  typedef std::map<void*, scoped_refptr<gl::GLImage>> ExternalSurfaceMap;
+  ExternalSurfaceMap surfaceMap_;
+};
+
+}  // namespace gles2
+}  // namespace gpu
+
+#endif
diff --git gpu/command_buffer/service/gles2_cmd_decoder.cc gpu/command_buffer/service/gles2_cmd_decoder.cc
index 25aa72a31a35..41403d716aa4 100644
--- gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -44,6 +44,7 @@
 #include "gpu/command_buffer/service/context_state.h"
 #include "gpu/command_buffer/service/decoder_client.h"
 #include "gpu/command_buffer/service/error_state.h"
+#include "gpu/command_buffer/service/external_texture_manager.h"
 #include "gpu/command_buffer/service/feature_info.h"
 #include "gpu/command_buffer/service/framebuffer_manager.h"
 #include "gpu/command_buffer/service/gl_stream_texture_image.h"
@@ -861,6 +862,13 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
     return group_->mailbox_manager();
   }

+  ExternalTextureManager* external_texture_manager() {
+    if (!external_texture_manager_.get()) {
+      external_texture_manager_.reset(new gles2::ExternalTextureManager());
+    }
+    return external_texture_manager_.get();
+  }
+
   ImageManager* image_manager() { return group_->image_manager(); }

   VertexArrayManager* vertex_array_manager() {
@@ -2484,6 +2492,7 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
   std::unique_ptr<GpuFenceManager> gpu_fence_manager_;

   std::unique_ptr<VertexArrayManager> vertex_array_manager_;
+  std::unique_ptr<ExternalTextureManager> external_texture_manager_;

   base::flat_set<scoped_refptr<Buffer>> writes_submitted_but_not_completed_;

@@ -5324,6 +5333,59 @@ error::Error GLES2DecoderImpl::HandleDestroyGpuFenceCHROMIUM(
   return error::kNoError;
 }

+error::Error GLES2DecoderImpl::HandleCreateSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CreateSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::CreateSharedTexture*>(cmd_data);
+  GLuint texture_id = c.texture_id;
+  uint32_t width = c.width;
+  uint32_t height = c.height;
+
+  typedef cmds::CreateSharedTexture::Result Result;
+  Result* result_dst = GetSharedMemoryAs<Result*>(
+      c.result_shm_id, c.result_shm_offset, sizeof(*result_dst));
+  if (!result_dst) {
+    return error::kOutOfBounds;
+  }
+
+  void* shared_handle = external_texture_manager()->CreateTexture(
+      texture_id, width, height, texture_manager());
+
+  *result_dst = (GLuint64)(shared_handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleLockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::LockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::LockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->LockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleUnlockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::UnlockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::UnlockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->UnlockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleDeleteSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::DeleteSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::DeleteSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->DeleteTexture(handle, texture_manager());
+  return error::kNoError;
+}
+
 void GLES2DecoderImpl::CreateBackTexture() {
   for (auto it = saved_back_textures_.begin(); it != saved_back_textures_.end();
        ++it) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
index ffe583de615e..286ebf4f217d 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
@@ -11,6 +11,7 @@
 #include "base/strings/string_split.h"
 #include "gpu/command_buffer/service/command_buffer_service.h"
 #include "gpu/command_buffer/service/decoder_client.h"
+#include "gpu/command_buffer/service/external_texture_manager.h"
 #include "gpu/command_buffer/service/feature_info.h"
 #include "gpu/command_buffer/service/gl_utils.h"
 #include "gpu/command_buffer/service/gpu_fence_manager.h"
@@ -2249,6 +2250,67 @@ error::Error GLES2DecoderPassthroughImpl::CheckSwapBuffersResult(
   return error::kNoError;
 }

+ExternalTextureManager*
+GLES2DecoderPassthroughImpl::external_texture_manager() {
+  if (!external_texture_manager_.get()) {
+    external_texture_manager_.reset(new gles2::ExternalTextureManager());
+  }
+  return external_texture_manager_.get();
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleCreateSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CreateSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::CreateSharedTexture*>(cmd_data);
+  GLuint texture_id = c.texture_id;
+  uint32_t width = c.width;
+  uint32_t height = c.height;
+
+  typedef cmds::CreateSharedTexture::Result Result;
+  Result* result_dst = GetSharedMemoryAs<Result*>(
+      c.result_shm_id, c.result_shm_offset, sizeof(*result_dst));
+  if (!result_dst) {
+    return error::kOutOfBounds;
+  }
+
+  void* shared_handle = external_texture_manager()->CreateTexture(
+      texture_id, width, height, nullptr);
+
+  *result_dst = (GLuint64)(shared_handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleLockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::LockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::LockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->LockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleUnlockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::UnlockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::UnlockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->UnlockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleDeleteSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::DeleteSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::DeleteSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->DeleteTexture(handle, nullptr);
+  return error::kNoError;
+}
+
 // static
 GLES2DecoderPassthroughImpl::TextureTarget
 GLES2DecoderPassthroughImpl::GLenumToTextureTarget(GLenum target) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
index 80fb15910e8d..8d325f264ce9 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
@@ -41,6 +41,7 @@ class GLFence;
 namespace gpu {
 namespace gles2 {

+class ExternalTextureManager;
 class ContextGroup;
 class GPUTracer;
 class PassthroughAbstractTextureImpl;
@@ -361,6 +362,8 @@ class GPU_GLES2_EXPORT GLES2DecoderPassthroughImpl : public GLES2Decoder {

   void SetOptionalExtensionsRequestedForTesting(bool request_extensions);

+  ExternalTextureManager* external_texture_manager();
+
   void* GetScratchMemory(size_t size);

   template <typename T>
@@ -541,6 +544,8 @@ class GPU_GLES2_EXPORT GLES2DecoderPassthroughImpl : public GLES2Decoder {

   std::unique_ptr<GpuFenceManager> gpu_fence_manager_;

+  std::unique_ptr<ExternalTextureManager> external_texture_manager_;
+
   // State tracking of currently bound 2D textures (client IDs)
   size_t active_texture_unit_;

diff --git ui/compositor/compositor.cc ui/compositor/compositor.cc
index fe0f3230192d..cd1e6aca6da3 100644
--- ui/compositor/compositor.cc
+++ ui/compositor/compositor.cc
@@ -537,6 +537,16 @@ void Compositor::OnNeedsExternalBeginFrames(bool needs_begin_frames) {
   needs_external_begin_frames_ = needs_begin_frames;
 }

+void* Compositor::GetSharedTexture() {
+  if (context_factory_private_)
+    return context_factory_private_->GetSharedTexture(this);
+  return nullptr;
+}
+
+void Compositor::EnableSharedTexture(bool enable) {
+  shared_texture_enabled_ = enable;
+}
+
 void Compositor::AddObserver(CompositorObserver* observer) {
   observer_list_.AddObserver(observer);
 }
diff --git ui/compositor/compositor.h ui/compositor/compositor.h
index e0ec33400b17..92a59ae3697e 100644
--- ui/compositor/compositor.h
+++ ui/compositor/compositor.h
@@ -161,6 +161,8 @@ class COMPOSITOR_EXPORT ContextFactoryPrivate {
                                        const viz::BeginFrameArgs& args) = 0;

   virtual void SetOutputIsSecure(Compositor* compositor, bool secure) = 0;
+
+  virtual void* GetSharedTexture(ui::Compositor* compositor) = 0;
 };

 // This class abstracts the creation of the 3D context for the compositor. It is
@@ -357,6 +359,10 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
     return task_runner_;
   }

+  void* GetSharedTexture();
+  void EnableSharedTexture(bool enable);
+  bool shared_texture_enabled() const { return shared_texture_enabled_; }
+
   // Compositor does not own observers. It is the responsibility of the
   // observer to remove itself when it is done observing.
   void AddObserver(CompositorObserver* observer);
@@ -494,6 +500,8 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   ExternalBeginFrameClient* external_begin_frame_client_ = nullptr;
   bool needs_external_begin_frames_ = false;

+  bool shared_texture_enabled_ = false;
+
   const bool force_software_compositor_;

   // The device scale factor of the monitor that this compositor is compositing
